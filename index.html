<!DOCTYPE html>

<html style="margin:0px; overflow: hidden; overscroll-behavior: none;">

<head>
    <meta name="viewport" 
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

    <style type="text/css">
        @font-face {
            font-family: 'Arial-Rounded Bold';
            src: url('/Arial-Rounded Bold.ttf');
        }

        canvas {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            outline: none;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0); /* mobile webkit */
        }
    </style>
</head>

<body style="margin:0px; overflow: hidden; scroll-margin: 0px; overscroll-behavior: none;">
    <canvas id="myCanvas" width="400" height="400">
        Canvas not supported
    </canvas>
    <p id="log">

    </p>

    <script>
        // #region javascript canvas and events boilerplate
        const canvas = document.getElementById("myCanvas");
        // const logger = document.getElementById("log");
        canvas.addEventListener("mousemove", e=>{if(e.buttons==1) onTouchMove(e.clientX, e.clientY);});
        canvas.addEventListener("mousedown", e=>onTouchDown(e.clientX, e.clientY));
        canvas.addEventListener("mouseup", e=>onTouchLift());
        document.addEventListener("keydown", e=>onKeyPress(e));
        canvas.addEventListener("leave", e=>onTouchLift());

        document.addEventListener('touchmove', function (event) {
        if (event.touches.length>1) { event.preventDefault(); }
        }, false);
        canvas.addEventListener("touchstart", e=>onTouchDown(e.touches[0].clientX, e.touches[0].clientY));
        canvas.addEventListener("touchend", e=>onTouchLift());

        document.addEventListener('gesturestart', function (event) {
        event.preventDefault(); }, false);

        canvas.addEventListener("touchmove", e=>{e.preventDefault=true;onTouchMove(e.touches[0].clientX, e.touches[0].clientY)});
        /** @type {CanvasRenderingContext2D}*/
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const canvasW = canvas.width;
        const canvasH = canvas.height;

        if (canvasW>canvasH) {
            window.alert("Landscape orientation is not supported, please rotate your phone and hit refresh");
            throw new Error();
        }

        /** @type {Number}*/
        let startTime;
        /** @type {Number}*/
        let previousTime;

        /** @param {Number} time*/
        function animation(time) {
            if (startTime == undefined)
                startTime = time;

            if (previousTime == undefined)
                previousTime = time;

            let deltaTime = time - previousTime;

            previousTime = time;

            if (deltaTime == 0)
                deltaTime = 1000 / 60.0;

            onFrame(time / 1000.0, deltaTime / 1000.0);

            window.requestAnimationFrame(animation)
        }

        window.requestAnimationFrame(animation);

        // #endregion

        const TOUCH_STATUS_NONE = "None";
        const TOUCH_STATUS_TOUCH = "Touch";
        const TOUCH_STATUS_HELD = "Held";
        const TOUCH_STATUS_OFF = "Off";
        const TOUCH_STATUS_LIFT = "Lift";

        class TouchArea {
            constructor(name, l, t, r, b) {
                this.name = name;
                this.l = l;
                this.t = t;
                this.r = r;
                this.b = b;
                this.status = TOUCH_STATUS_NONE;
                this.wasOff = false;
                this.wasLifted = false;
                this.canvasJustTouched = false;
            }

            updateStatus(isTouched) {
                if (this.wasLifted) {
                    // make sure status is TOUCH_STATUS_LIFT for exactly one frame
                    this.wasLifted = false;
                    if (this.status == TOUCH_STATUS_HELD || 
                        this.status == TOUCH_STATUS_TOUCH) {
                            this.status = TOUCH_STATUS_LIFT;
                            return;
                    }
                    else {
                        this.status = TOUCH_STATUS_NONE;
                    }
                    
                }

                if (isTouched && this.status == TOUCH_STATUS_NONE && this.canvasJustTouched) {
                    this.status = TOUCH_STATUS_TOUCH;
                    this.wasOff = false;
                }
                else if (isTouched && this.status == TOUCH_STATUS_TOUCH) 
                    this.status = TOUCH_STATUS_HELD;
                else if (!isTouched && this.status == TOUCH_STATUS_HELD) {
                    this.status = TOUCH_STATUS_OFF;
                    this.wasOff = true;
                }
                else if (isTouched && this.status == TOUCH_STATUS_OFF)
                    this.status = TOUCH_STATUS_HELD;
                else if (this.status == TOUCH_STATUS_LIFT)
                    this.status = TOUCH_STATUS_NONE;

                this.canvasJustTouched = false;
            }

            lift() {
                this.wasLifted = true;
            }

            canvasTouched() {
                this.canvasJustTouched = true;
            }

            isHeld(requirePersistent = false) {
                return this.status == TOUCH_STATUS_HELD && (!requirePersistent || !wasOff);
            }

            isLifted(requirePersistent = false) {
                return this.status == TOUCH_STATUS_LIFT && (!requirePersistent || !wasOff);
            }
        }

        let touchAreas = [];

        /** @returns {TouchArea} */
        function getTouchArea(name) {
            return touchAreas.find(x=>x.name == name);
        }

        let playerName = localStorage.getItem("playerName");
        playerName = window.prompt("Enter player name", ""+playerName=="null" ? "" : playerName);
        localStorage.setItem("playerName", playerName);


        let levelRequestCooldown = -1;

        if ("WebSocket" in window) {
            console.log(location);
            var socket = new WebSocket(`ws://${location.hostname}:8000/ws`);
            
            socket.onopen = function() {
                console.log("WebSocket connection established.");
                socket.send(`RegisterPlayer:${playerName}[levelSizeRatio=${(canvasH-desiredResetBtnHeight)/canvasW}]`);
                levelRequestCooldown = 0;
            };

            socket.onmessage = function(event) {
                /**@type {String} */
                const message = event.data;
                console.log("Received message: " + message);
                let match = message.match("^([a-zA-Z0-9_]*):([\\s\\S]*)$");
                
                if (match) {
                    if(match[1] == "level") {
                        levelRequestCooldown = 0;
                        let parts = match[2].split(";");
                        let levelID = parseInt(parts[0]);
                        let gridSizeX = parseInt(parts[1]);
                        let brightness = parseFloat(parts[2]);
                        let levelString = parts[3];

                        onLevelDataRecieved(levelID, gridSizeX, brightness, levelString);
                    }
                    else if (match[1] == "lobby") {
                        let parts = match[2].split("/");
                        let playersReady = parseInt(parts[0]);
                        let lobbySize = parseInt(parts[1]);

                        onLobbyInfoRecieved(playersReady, lobbySize);
                    }
                    else if (match[1] == "message") {
                        let parts = match[2].split(";", 3);
                        let bgFillStyle = parts[0];
                        let fgFillStyle = parts[1];
                        let message = parts[2];

                        onMessageRecieved(message, fgFillStyle, bgFillStyle);
                    }
                    else if (match[1] == "overlay_message") {
                        let parts = match[2].split(";", 4);
                        let displayTime = parseFloat(parts[0]);
                        let animation = parts[1];
                        let fillStyle = parts[2];
                        let message = parts[3];

                        onOverlayMessageRecieved(message, fillStyle, displayTime, animation);
                    }
                    
                }
                
            };

            socket.onerror = function(error) {
                console.error("WebSocket error: " + error);
            };

            socket.onclose = function(event) {
                console.log("WebSocket connection closed with code: " + event.code);
                setInterval(function () {location.reload()}, 1000);
            };
        }
        else
            alert('Not supported');


        let nextLevelID = 1;
        /** @type Level? */
        let level = null;

        let lobby = null;

        let message = null;
        let messageFgFillStyle = "#fff";
        let messageBgFillStyle = "#000";

        class OverlayMessage {
            constructor(message, fillStyle, displayTime = 1.0, animation = "none") {
                this.message = message;
                this.fillStyle = fillStyle;
                this.displayTime = displayTime;
                this.animation = animation;
            }
        }

        let requestedOverlayMessage = null;

        let overlayMessage = null;

        let overlayMessageStartTime = -100000;

        class Lobby {
            constructor(lobbySize, readyCount) {
                this.lobbySize = lobbySize;
                this.readyCount = readyCount;
            }
        }

        class Level {
            constructor(blocks, gridSizeX, gridSizeY, brightness) {
                /** @type Number[] */
                this.blocks = blocks;
                /** @type Number */
                this.gridSizeX = gridSizeX;
                /** @type Number */
                this.gridSizeY = gridSizeY;
                /** @type Number */
                this.brightness = brightness;
            }

            getScaleFactor(canvasWidth) {
                return canvasWidth / (this.gridSizeX * BLOCK_SIZE);
            }

            getBlock(x, y) {
                return this.blocks[y * this.gridSizeX + x];
            }

            setBlock(x, y, value) {
                this.blocks[y * this.gridSizeX + x] = value;
            }

            isSolid(x, y) {
                return x < 0 || x >= this.gridSizeX || y < 0 || y >= this.gridSizeY || this.getBlock(x, y) == BLOCK_SOLID;
            }
        }

        function requestNextLevel() {
            socket.send(`RequestLevel:${nextLevelID}`);
            levelRequestCooldown = 60;
        }

        function announceReady() {
            socket.send(`AnnounceReady:`);
        }

        function announceProgress() {
            if (level!=null) {
                let levelBytes = new Uint8Array(Math.ceil(level.blocks.length / 4) * 4);
                levelBytes.set(level.blocks);
                let compressedLevelBytes = new Uint8Array(levelBytes.length/4);

                for(let i = 0; i<levelBytes.length; i+=4) {
                    let byte = 0;
                    byte |= levelBytes[i+0] << (2*0);
                    byte |= levelBytes[i+1] << (2*1);
                    byte |= levelBytes[i+2] << (2*2);
                    byte |= levelBytes[i+3] << (2*3);
                    compressedLevelBytes[i/4] = byte;
                }

                socket.send(`AnnounceProgress:${level.gridSizeX};${level.gridSizeY};${
                    btoa(String.fromCharCode.apply(null, compressedLevelBytes))
                }`);
            }

        }

        function onLevelDataRecieved(levelID, gridSizeX, brightness, data) {
            let blocks = data.split("").map(function(item) {
                return parseInt(item, 10);
            });

            player = new Player();

            const actualBlockSize = canvasW / gridSizeX;
            const gridSizeY = Math.floor((canvasH - desiredResetBtnHeight) / actualBlockSize);
            const resetBtnTop = gridSizeY * actualBlockSize;

            touchAreas = [
                new TouchArea("resetButton", 0, resetBtnTop, canvasW, canvasH)
            ];

            // fill up blocks as necessary
            if (gridSizeX*gridSizeY > blocks.length)
                blocks = blocks.concat(Array(gridSizeX*gridSizeY - blocks.length).fill(1));

            let newLevel = new Level(blocks, gridSizeX, gridSizeY, brightness);
            newLevel.setBlock(player.x, player.y, BLOCK_COLOR);
            level = newLevel;

            gameState = GAMESTATE_PLAYING;

            nextLevelID = levelID+1;
        }

        function onLobbyInfoRecieved(readyCount, lobbySize) {
            const buttonHeight = canvasW/3;

            touchAreas = [
                new TouchArea("readyButton", canvasW/20, canvasH/2 - buttonHeight/2, 
                                   canvasW - canvasW/20, canvasH/2 + buttonHeight/2)
            ];

            lobby = new Lobby(lobbySize, readyCount);

            gameState = GAMESTATE_WAITING_LOBBY;
        }

        function onMessageRecieved(_message, fgFillStyle, bgFillStyle) {
            messageFgFillStyle =fgFillStyle;
            messageBgFillStyle =bgFillStyle;
            message = _message;

            gameState = GAMESTATE_DISPLAY_MESSAGE;
        }

        function onOverlayMessageRecieved(message, fillStyle, displayTime, animation) {
            requestedOverlayMessage = new OverlayMessage(message, fillStyle, displayTime, animation);
        }


        class Player {
            constructor() {
                this.x = 0.0;
                this.y = 3.0;
                this.speedX = 0.0;
                this.speedY = 0.0;
            }
        }

        let player = new Player();

        const BLOCK_NONE = 0;
        const BLOCK_SOLID = 1;
        const BLOCK_COLOR = 2;

        const GAMESTATE_WAITING = "Waiting";
        const GAMESTATE_WAITING_LOBBY = "WaitingInLobby";
        const GAMESTATE_PLAYING = "Playing";
        const GAMESTATE_DISPLAY_MESSAGE = "DisplayMessage";
        
        let gameState = GAMESTATE_WAITING;

        const BLOCK_SIZE = 20;

        let desiredResetBtnHeight = canvasW/4.0;

        function reset() {
            player = new Player();
        }

        let resetBtnFillAmount = 0;

        let prevClientX;
        let prevClientY;

        function onTouchDown(clientX, clientY) {
            prevClientX = clientX;
            prevClientY = clientY;

            for (const area of touchAreas)
                area.canvasTouched();
        }

        function onTouchLift() {
            prevClientX = null;
            prevClientY = null;

            for (const area of touchAreas)
                area.lift();
        }
        /** @param newClientX {Number}
         *  @param newClientY {Number}
        */
        function onTouchMove(newClientX, newClientY) {
            if (prevClientX == null) {
                prevClientX = newClientX;
                prevClientY = newClientY;
            }

            if (gameState == GAMESTATE_PLAYING) {
                let deltaX = newClientX - prevClientX;
                let deltaY = newClientY - prevClientY;

                if ((deltaX * deltaX + deltaY * deltaY) > 2 &&
                    player.speedX == 0 && player.speedY == 0) {
                    if (Math.abs(deltaX) > Math.abs(deltaY))
                        player.speedX = Math.sign(deltaX) * 60;
                    else
                        player.speedY = Math.sign(deltaY) * 60;
                }
            }

            prevClientX = newClientX;
            prevClientY = newClientY;
        }

        /** @param e {KeyboardEvent}
        */
        function onKeyPress(e) {
            if (player.speedX!=0 || player.speedY!=0)
                return;

            switch (e.key) {
                case "ArrowLeft":
                case "a":
                    player.speedX = -60;
                    break;
                case "ArrowRight":
                case "d":
                    player.speedX = 60;
                    break;
                case "ArrowUp":
                case "w":
                    player.speedY = -60;
                    break;
                case "ArrowDown":
                case "s":
                    player.speedY = 60;
                    break;
            
                default:
                    break;
            }
        }

        let frameCount = 0;

        /** @param {Number} deltaTime
            @param {Number} time*/
        function onFrame(time, deltaTime) {

            function lerp(t, a, b) {
                return (1-t)*a + t*b;z
            }

            if (socket.readyState == socket.CLOSED) {
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, canvasW, canvasH);
                let fontSize = Math.round(canvasW/8);
                ctx.font = `${fontSize}px Arial-Rounded Bold`;
                ctx.fillStyle = "#fff";
                ctx.textAlign = "center";
                ctx.fillText("Connection Lost", canvasW/2, canvasH/2 + fontSize/3);
                
                return;
            }

            if (gameState == GAMESTATE_DISPLAY_MESSAGE) {
                ctx.fillStyle = messageBgFillStyle;
                ctx.fillRect(0, 0, canvasW, canvasH);
                let fontSize = Math.round(canvasW/8);
                ctx.font = `${fontSize}px Arial-Rounded Bold`;
                ctx.fillStyle = messageFgFillStyle;
                ctx.textAlign = "center";
                let lines = message.split("\n");

                let i = 0;
                for (line of lines) {
                    let offset = (-lines.length/2+i) * fontSize;
                    ctx.fillText(line, canvasW/2, canvasH/2 + offset + fontSize/3);
                    i++;
                }

                return;
            }

            {
                let anyTouched = false;
                for (let index = touchAreas.length - 1; index >= 0; index--) {
                    /**@type {TouchArea} */
                    const area = touchAreas[index];
                    const isTouched = !anyTouched &&
                                    area.l <= prevClientX && prevClientX <= area.r && 
                                    area.t <= prevClientY && prevClientY <= area.b;
                    
                    area.updateStatus(isTouched);
                    anyTouched |= isTouched;
                }
            }

            // player movement
            if (gameState == GAMESTATE_PLAYING && level != null) {
                let deltaX = player.speedX * deltaTime;
                let deltaY = player.speedY * deltaTime;
                let steps = Math.ceil(Math.max(Math.abs(deltaX), Math.abs(deltaY))/0.49);

                for (let i = 0; i < steps; i++) {
                    player.x += deltaX / steps;
                    player.y += deltaY / steps;

                    let checkDirX = Math.sign(deltaX);
                    let checkDirY = Math.sign(deltaY);

                    let fieldX = Math.round(player.x) + checkDirX;
                    let fieldY = Math.round(player.y) + checkDirY;

                    if (level.isSolid(fieldX, fieldY)) {
                        // resolve collision
                        player.x = fieldX - checkDirX;
                        player.y = fieldY - checkDirY;

                        if (level.getBlock(player.x, player.y) == BLOCK_NONE)
                            level.setBlock(player.x, player.y, BLOCK_COLOR);

                        player.speedX = 0.0;
                        player.speedY = 0.0;
                        console.log("Stop");
                        break;
                    }

                    level.setBlock(Math.round(player.x), Math.round(player.y), BLOCK_COLOR);
                }
            }

            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvasW, canvasH);
            
            //draw level and handle completion
            if (level != null) {
                let scaling = level.getScaleFactor(canvasW);

                function rectLTRB(l, t, r, b, path=null) {
                    l = Math.round(l * scaling);
                    t = Math.round(t * scaling);
                    r = Math.round(r * scaling);
                    b = Math.round(b * scaling);

                    if (path!=null)
                        path.rect(l, t, r-l, b-t);
                    else
                        ctx.fillRect(l, t, r-l, b-t);
                }

                function rect(x, y, w, h, path=null) {
                    rectLTRB(x, y, x+w, y+h, path);
                }

                function ellipseLTRB(l, t, r, b) {
                    l = Math.round(l * scaling);
                    t = Math.round(t * scaling);
                    r = Math.round(r * scaling);
                    b = Math.round(b * scaling);
                    ctx.beginPath();
                    ctx.ellipse((l+r)/2, (t+b)/2, (r-l)/2, (b-t)/2, 0, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fill();
                }

                function ellipse(x, y, w, h) {
                    ellipseLTRB(x, y, x+w, y+h);
                }

                let emptyCount = 0;
                let filledCount = 0;

                let blocksLighter = new Path2D();
                let blocksDarker = new Path2D();
                let colorBlocks = new Path2D();
                let voidMask = new Path2D();

                for (let x = 0; x < level.gridSizeX; x++) {
                    for (let y = 0; y < level.gridSizeY; y++) {
                        switch (level.getBlock(x, y)) {
                            case BLOCK_NONE:
                                rect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, voidMask);
                                emptyCount++;
                                break;
                            case BLOCK_SOLID:
                                if (x % 2 == y % 2)
                                    rect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, blocksLighter);
                                else
                                    rect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, blocksDarker);

                                
                                break;
                            case BLOCK_COLOR:
                                filledCount++;

                                ctx.fillStyle = "#f55";
                                rect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, colorBlocks);
                                break;

                            default:
                                break;
                        }
                    }
                }

                let hue = (nextLevelID-2)*30;
                let glowStrength = 0.5+Math.sin(time)*0.5;
                let brightness = level.brightness;

                const steps = 10;

                ctx.lineJoin = "round";
                ctx.strokeStyle = `hsl(${hue}, 100%, 70%, ${100 / steps * glowStrength}%)`;

                for (let i = 1; i <= steps; i++) {
                    t=i/steps;

                    inv_f = Math.sqrt(1/t);

                    ctx.lineWidth = t*16;
                    ctx.stroke(colorBlocks);
                }

                ctx.fillStyle = "#000";
                ctx.fill(voidMask);

                ctx.fillStyle = `hsl(${hue}, 100%, 70%)`;
                ctx.fill(colorBlocks);

                ctx.fillStyle = `hsl(0, 0%, 30%, ${Math.round(100*brightness)}%)`;
                ctx.fill(blocksDarker);
                ctx.fillStyle = `hsl(0, 0%, 50%, ${Math.round(100*brightness)}%)`;
                ctx.fill(blocksLighter);
                

                {
                    let t = 0;
                    let b = scaling * BLOCK_SIZE * 3;
                    let fontSize = Math.round((b-t)*0.9);
                    ctx.font = `${fontSize}px Arial-Rounded Bold`;
                    ctx.textAlign = "center";
                    ctx.fillStyle = "#0008";
                    rectLTRB(0, 0, level.gridSizeX*BLOCK_SIZE, 3*BLOCK_SIZE);
                    ctx.fillStyle = ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
                    ctx.fillText(`Level ${nextLevelID-1}`, canvasW/2, (t+b)/2+fontSize/3);
                }
                

                ctx.fillStyle = ctx.strokeStyle = `hsl(${hue}, 100%, 30%)`;
                ellipse(player.x * BLOCK_SIZE,
                    player.y * BLOCK_SIZE,
                    BLOCK_SIZE, BLOCK_SIZE);

                let resetButton = getTouchArea("resetButton");

                if (resetButton != null) {
                    ctx.fillStyle = "#800"
                    rectLTRB(0, resetButton.t / scaling, canvasW / scaling, canvasH / scaling);
                    let resetBtnHeight = canvasH-resetButton.t;
                    let fontSize = Math.round(resetBtnHeight*0.4);
                    ctx.font = `${fontSize}px Arial-Rounded Bold`;
                    ctx.scale(0.9, 1.0);
                    ctx.translate(canvasW/2*(1/0.9-1), 0);
                    ctx.fillStyle = "#f00";
                    ctx.textAlign = "center";
                    ctx.fillText("RESET POSITION", canvasW/2, (resetButton.t + canvasH)/2 + fontSize/3);
                    ctx.resetTransform();

                    ctx.fillStyle = "#0003"
                    rectLTRB(0, resetButton.t/scaling, canvasW/scaling, 
                        lerp(Math.pow(resetBtnFillAmount, 0.2), canvasH, resetButton.t) / scaling);

                    if (resetButton.isHeld()) {
                        resetBtnFillAmount += 0.5 * deltaTime;

                        if (resetBtnFillAmount > 1.0) {
                            reset();
                            resetButton.lift();
                        }
                    }
                    else {
                        resetBtnFillAmount = 0.0;
                    }
                }

                if (gameState == GAMESTATE_PLAYING) {
                    if (frameCount%10 == 0)
                        announceProgress();

                    if (emptyCount == 0) {
                        if (levelRequestCooldown == 0) {
                            gameState = GAMESTATE_WAITING;
                            requestNextLevel();
                        }
                    }
                }
            }
            

            if (gameState == GAMESTATE_WAITING) {
                ctx.fillStyle = "#0008";
                ctx.fillRect(0, 0, canvasW, canvasH);
                let fontSize = Math.round(canvasW/10);
                ctx.font = `${fontSize}px Arial-Rounded Bold`;
                ctx.fillStyle = "#fff";
                ctx.textAlign = "center";
                ctx.fillText("Loading"+".".repeat(time%4), canvasW/2, canvasH/2);
            }

            if (gameState == GAMESTATE_WAITING_LOBBY) {
                let readyButton = getTouchArea("readyButton");

                if (readyButton != null) {
                    ctx.fillStyle = readyButton.isHeld() ? "#0f0" : "#0c0";

                    let btn = readyButton;
                    ctx.fillRect(btn.l, btn.t, btn.r-btn.l, btn.b-btn.t);
                    ctx.strokeStyle = "#0008";
                    ctx.lineWidth = 20;
                    ctx.strokeRect(btn.l, btn.t, btn.r-btn.l, btn.b-btn.t);

                    let fontSize = Math.round((btn.b-btn.t)/2);
                    ctx.font = `${fontSize}px Arial-Rounded Bold`;
                    ctx.fillStyle = "#fff";
                    ctx.textAlign = "center";
                    ctx.fillText("Ready!", (btn.r-btn.l)/2, (btn.t+btn.b)/2+fontSize/3);

                    if (readyButton.isLifted()) {
                        announceReady();
                    }
                    
                    if (lobby != null) {
                        ctx.font = `${fontSize*0.5}px Arial-Rounded Bold`;
                        ctx.fillStyle = "#fff";
                        ctx.textAlign = "center";
                        let text = lobby.lobbySize == 1 ? "No other players yet" :
                            `Ready players: ${lobby.readyCount}/${lobby.lobbySize}`;
                        ctx.fillText(text, 
                            (btn.r-btn.l)/2, (btn.t+btn.b)/2+fontSize * 2);
                    }
                    
                }
            }

            if (requestedOverlayMessage != null) {
                overlayMessage = requestedOverlayMessage;
                overlayMessageStartTime = time;
                requestedOverlayMessage = null;
            }

            if (overlayMessage != null) {
                let t = Math.min((time-overlayMessageStartTime)/overlayMessage.displayTime, 1.0);

                let lines = overlayMessage.message.split("\n");
                let fontSize = Math.round(canvasW/8);
                ctx.font = `${fontSize}px Arial-Rounded Bold`;

                let max = 0;
                for (line of lines) {
                    max = Math.max(
                        max,
                        ctx.measureText(line).width
                    );
                }
                let fontScaling = (canvasW*0.8)/max;
                fontSize = Math.round(fontSize*fontScaling);
                ctx.font = `${fontSize}px Arial-Rounded Bold`;

                ctx.globalAlpha = 1.0;

                let y = canvasH/2;
                let s = 1.0;

                switch (overlayMessage.animation) {

                    case "fly-in":
                        y = -canvasH/2 + canvasH * Math.pow(t, 0.2);
                        ctx.globalAlpha = 1.0-Math.pow(t, 10);
                        break;
                    case "pop-in":
                        //todo

                    case "none":
                    default:
                        break;
                }

                ctx.fillStyle = "#0007";
                let top = y-fontSize*lines.length/2-20;
                let bottom = y+fontSize*lines.length/2+20;
                ctx.fillRect(0, top, canvasW, bottom-top);

                ctx.fillStyle = overlayMessage.fillStyle;
                
                ctx.textAlign = "center";
                let i = 0;
                for (line of lines) {
                    let offset = (-(lines.length-1)/2+i) * fontSize;
                    ctx.fillText(line, canvasW/2, y + offset + fontSize/3);
                    i++;
                }

                ctx.globalAlpha = 1.0;

                if (t >=1.0)
                    overlayMessage = null;
            }

            if (levelRequestCooldown > 0)
                levelRequestCooldown--;

            frameCount++;

        }
    </script>
</body>

</html>